#!/bin/bash
# Little script to run a chaperone docker container in the local directory
# for development or other purposes.

DEFAULT_IMAGE="chapdev/chaperone-baseimage"
VERSTR="chaplocal version 1.1"

if [ "$CHAP_SERVICE_NAME" != "" ]; then
   echo "The 'chaplocal' script is not intended to be run inside a container,"
   echo "but for use on the docker host to set up local development directories."
   echo "Maybe you meant 'get-chaplocal'?"
   exit 1
fi

if [ "$1" == '-V' ]; then
   echo $VERSTR
   exit
fi

if [ "$1" == '-d' ]; then
   runopts="-d"
   shift
else
   runopts=""
fi

IMAGE="$2"
if [ $# == 1 ]; then
   IMAGE=$DEFAULT_IMAGE
elif [ $# != 2 ]; then
   echo ""
   echo "Usage: chaplocal [-d] local-apps-dir [image-name]"
   echo ""
   echo "Runs the specified chaperone image and uses local-apps-dir for the apps"
   echo "directory.  Creates a script in local-apps-dir called run.sh so you can"
   echo "run an interactive (default) or daemon instance."
   echo ""
   echo "Will run all container processes under the current user account with the"
   echo "local drive mounted as a shared volume in the container."
   echo ""
   echo "If not specified, the the image '$DEFAULT_IMAGE' will be used."
   echo ""
   exit
fi

APPSBASE="$1"
LOCALROOT=$PWD

APPSDIR=$LOCALROOT/$APPSBASE

# Assure we're running in /home
if [ "${PWD:0:6}" != "/home/" ]; then
  echo "Sorry, this script is designed to operate only within the /home directory"
  echo "of your host. :-("
  exit 1
fi

# Extract our local UID/GID
myuid=`id -u`
mygid=`id -g`

if [[ "$IMAGE" != *":"* ]]; then
  IMAGE=$IMAGE:latest
fi

if [ "`docker inspect $IMAGE >/dev/null 2>&1 && echo yes`" != "yes" ]; then
  echo ""
  echo Cannot find local docker image: $IMAGE
  echo ""
  echo You may want to pull the image with \"docker pull $IMAGE\" 
  echo and then try again.
  exit 1
fi

function initapps() {

mkdir -p $APPSDIR/build

cat >$APPSDIR/build/Dockerfile <<EOF
FROM $IMAGE
ADD . /setup/
RUN /setup/build/install.sh
EOF

cat >$APPSDIR/build/install.sh <<'QEOF'
cd /setup
# remove existing chaperone.d and startup.d from /apps so none linger
rm -rf /apps/chaperone.d /apps/startup.d
# copy everything from setup to the root /apps
tar cvf - --exclude 'build*' --exclude 'run.sh' . | (cd /apps; tar xf -)
# Add additional setup commands for your production image here, if any.
rm -rf /setup
QEOF
chmod ugo+x $APPSDIR/build/install.sh

cat >$APPSDIR/bash.bashrc <<'QEOF'
export PROMPT_DIRTRIM=2
# Created by chaplocal
cd $APPS_DIR
echo ""
echo "Now running inside container. Directory is: $APPS_DIR"
echo ""
QEOF

cat >$APPSDIR/build.sh <<'QEOF'
#!/bin/bash
#Created by chaplocal on `date`
# the cd trick assures this works even if the current directory is not current.
cd ${0%/*}
if [ $# != 1 ]; then
  echo "Usage: ./build.sh <production-image-name>"
  exit 1
fi
prodimage="$1"
if [ ! -f build/Dockerfile ]; then
  echo "Expecting to find Dockerfile in ./build ... not found!"
  exit 1
fi
tar czh --exclude '*~' --exclude 'var/*' . | docker build -t $prodimage -f build/Dockerfile -
QEOF
chmod ugo+x $APPSDIR/build.sh

cat >$APPSDIR/run.sh <<EOF
#!/bin/bash
#Created by chaplocal on `date`

IMAGE="$IMAGE"

usage() {
  echo "Usage: run.sh [-d] [-p port#] [-h] [extra-chaperone-options]"
  echo "       Run $IMAGE as a daemon or interactively (the default)."
  echo "       First available port will be remapped to localhost if possible."
  exit
}

cd \${0%/*} # go to directory of this file
APPS=\$PWD
cd ..

options="-t -i -e TERM=\$TERM --rm=true"
shellopt="/bin/bash --rcfile \$APPS/bash.bashrc"

while getopts ":-dp:" o; do
  case "\$o" in
    d)
      options="-d"
      shellopt=""
      ;;
    p)
      portopt="-p \$OPTARG"
      ;;      
    -) # first long option terminates
      break
      ;;
    *)
      usage
      ;;
  esac
done
shift \$((OPTIND-1))

# Extract our local UID/GID
myuid=\`id -u\`
mygid=\`id -g\`

if [ "\$portopt" == "" ]; then
  exposed=\`docker inspect \$IMAGE | sed -ne 's/^ *"\\([0-9]*\\)\\/tcp".*$/\\1/p' - | head -1\`
  if [ "\$exposed" != "" -a -x /bin/nc ] && ! /bin/nc -z localhost \$exposed; then
    portopt="-p \$exposed:\$exposed"
    echo "Port \$exposed available at localhost:\$exposed ..."
  fi
fi

# Run the image with this directory as our local apps dir.
# Create a user with uid=\$myuid inside the container so the mountpoint permissions
# are correct.

docker run \$options -v /home:/home \$portopt $IMAGE \\
   --create \$USER/\$myuid --config \$APPS/chaperone.d \$* \$shellopt
EOF
chmod ugo+x $APPSDIR/run.sh
}

# Copy the boilerplate apps directory into this development directory where it can be
# worked on easily.
if [ ! -d $APPSDIR ]; then
    echo ""
    echo Extracting /apps default directory into $APPSDIR ...
    docker run -i --rm=true -v /home:/home $IMAGE --disable --exitkills --log err \
	/bin/bash -c "cp -a /apps $APPSDIR; chown -R $myuid:$mygid $APPSDIR"
    initapps
    echo "You can customize the contents of $APPSDIR to tailor it for your application,"
    echo "then use it as a template for your production image."
    echo ""
    if [ -x $APPSDIR/bin/chaplocal ]; then
       THEIRVER=`$APPSDIR/bin/chaplocal -V`
       if [ "$THEIRVER" != "$VERSTR" ]; then
	   echo "WARNING: This image uses a different version of chaplocal."
	   echo "         Ours:   $VERSTR"
	   echo "         Image:  $THEIRVER"
	   echo ""
       fi
    fi
    echo Executing run.sh within $APPSDIR ...
    echo ""
elif [ ! -f $APPSDIR/run.sh ]; then
    echo "$APPSDIR already exists but doesn't seem to be one I created (no run.sh in there)"
    echo "You're on your own"
    exit 1
else
    echo ""
    echo $APPSDIR already exists.
    echo Executing run.sh within $APPSDIR ...
    echo ""
fi

$APPSDIR/run.sh $runopts
